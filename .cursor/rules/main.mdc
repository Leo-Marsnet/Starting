---
description: 
globs: 
alwaysApply: true
---
# AI 协作与项目开发高级准则 (main.mdc)

---

## 1. 核心协作流程 (四阶段法)

在启动任何任务前，严格遵循以下四阶段协作流程，确保需求理解一致，避免无效返工。

*   **第一阶段：需求分析**
    *   **任务**: 仔细分析和理解用户提出的需求、问题或任务。
    *   **AI行为**: 深入思考需求的根本目标，识别潜在的歧义和缺失信息。遵循下述"前置分析原则"。

*   **第二阶段：确认沟通**
    *   **任务**: 将我的理解反馈给用户，并寻求确认。
    *   **AI行为**: 清晰地阐述我对需求的理解、提出澄清问题、并主动建议技术实现方案或替代方案。

*   **第三阶段：等待确认**
    *   **任务**: 等待用户的明确指令。
    *   **AI行为**: **在收到用户明确的 "同意"、"开始" 或类似指令前，绝不开始执行编码或实质性操作。** 这是最关键的一步。

*   **第四阶段：执行阶段**
    *   **任务**: 在确认无误后，高效、高质量地完成任务。
    *   **AI行为**: 遵循本文件后续的技术与设计准则，进行代码实现、问题修复或其他操作。

### 1.1 前置分析原则

*   **用户画像假设**: 默认用户为非技术背景的"产品负责人"，沟通时应主动避免使用技术术语，将复杂技术问题转化为简单的选择题或解决方案描述。
*   **需求明确性检查**: 如果需求模糊，必须通过提问获取澄清。提问应聚焦于业务目标而非技术实现，例如：
    *   这个功能的核心目标是什么？
    *   需要展示哪些关键信息？
    *   用户可以进行哪些核心操作？
*   **技术可行性评估**: 主动评估需求是否在纯前端技术栈（如Vite/Next.js）内可独立完成。若涉及以下技术，需明确告知用户当前范围所限：
    *   独立数据库（如 MySQL, MongoDB）
    *   独立缓存系统（如 Redis）
    *   复杂的后端架构或微服务
    *   特定的服务器运维或部署需求

---

## 2. UI/UX 设计准则 (Apple iOS 风格)

所有用户界面的设计与开发，必须遵循以下源于 Apple iOS 设计哲学的准则，旨在创造简洁、直观、优雅且用户友好的体验。

### 2.1 核心原则

*   **简洁与清晰**: 这是设计的基石。界面必须干净、整洁，聚焦于核心功能与内容。优先移除所有不必要的装饰和视觉噪音。
*   **操作直观 (易用性)**: 设计应具有高度的可预测性。通过一致的设计模式、清晰的视觉层级和即时反馈，让用户无需学习即可自然上手。
*   **优雅与精致**: 强烈强调美学吸引力。通过平滑流畅的动画、和谐的色彩搭配、精美的图标和优质的排版，营造出高级感和专业感。

### 2.2 视觉与交互要素

*   **设计语言 (深度与层次)**:
    *   **基础**: 采用现代扁平化设计。
    *   **层次感**: 通过**微妙的阴影、柔和的渐变和半透明/模糊效果 (毛玻璃)** 来营造视觉上的深度和元素间的层级关系，但要避免过度的拟物化。
*   **布局与间距**:
    *   **留白**: 大量、有效地使用留白（负空间）来减少视觉混乱，突出重要内容，创造开放和通透的感觉。
    *   **卡片式UI**: 积极采用带有圆角的"卡片"作为内容容器，以实现清晰的视觉分离和内容组织。
*   **字体与排版 (Typography)**:
    *   **字体**: 必须选用清晰、现代、高度可读的无衬线字体 (如 Inter, San Francisco, Helvetica Neue)。
    *   **排版**: 保证文本层级分明，间距、行高设置合理，以获得最佳阅读体验。
*   **动画与过渡**:
    *   **目的性**: 动画必须是**流畅、自然且有目的的**。它们用于提供操作反馈、引导用户注意力、或平滑地切换上下文，绝非为了炫技。
    *   **物理隐喻**: 动画应遵循一定的物理规律，使其感觉更真实、更灵敏（例如，列表滚动末端的回弹效果）。
*   **图标 (Iconography)**:
    *   **风格**: 图标应**极简、表意明确**。优先使用轮廓清晰的线条图标或轻量化的填充图标。
    *   **一致性**: 整个应用中的图标必须保持风格和视觉重量的一致性。

---

## 3. 技术架构与最佳实践

### 3.1 架构设计

*   **模块化**: 强制进行模块化设计。按业务领域或功能职责（如 `inventory`, `sales`, `finance`）划分代码、状态和逻辑。
*   **可扩展性**: 设计应考虑未来的功能扩展，避免硬编码和紧耦合。
*   **可维护性**: 编写清晰、自解释的代码，遵循单一职责原则（SRP）。

### 3.2 核心技术栈与预置库

本模版已预置并配置好以下核心库，作为项目开发的标准基础：

*   **语言**: **TypeScript** (已开启 `strict` 模式)
*   **前端框架**: **React**
*   **构建工具**: **Vite**
*   **UI 组件库**: **shadcn/ui** (基于 Tailwind CSS)
*   **状态管理**: **Zustand**
*   **数据请求**: **TanStack Query (React Query)**
*   **列表虚拟化**: **TanStack Virtual**
*   **代码格式化**: **Prettier**
*   **静态检查**: **ESLint**

### 3.3 编码实践

*   **类型安全**: 追求 **100% 的 TypeScript 类型覆盖率**。避免使用 `any` 类型，除非有绝对必要的理由并加以注释说明。
*   **性能优化**:
    *   **主动应用**: 默认对可能重复渲染的组件使用 `React.memo`。
    *   **精细控制**: 使用 `useMemo` 缓存昂贵的计算结果，使用 `useCallback` 来稳定函数引用。
    *   **长列表**: 必须使用虚拟化技术（如 `TanStack Virtual`）来处理大数据量列表的渲染。
*   **代码质量**:
    *   **零容忍**: 保持 ESLint 和 Prettier 检查**零错误、零警告**。
    *   **DRY 原则**: 避免重复代码 (Don't Repeat Yourself)。
*   **错误处理**: 使用 `try-catch` 块和错误边界（Error Boundaries）优雅地处理运行时错误，并向用户提供有意义的反馈。

---

## 4. AI 辅助开发的特定指令

### 元指令 (Meta-Instruction)
*   **内部推理语言**: 为保证最高效和最精确的逻辑推理，AI在内部思考复杂问题时建议使用英文。
*   **外部沟通语言**: 所有面向用户的**沟通**、代码中的**注释**和最终生成的**文档**（如README.md）都**必须使用中文**。

### 4.1 编码建议

*   **交付物要求**: 必须提供一步到位的完整解决方案，确保代码能在最小配置的环境中直接运行，避免让用户进行额外的编码、配置或复杂的环境安装。
*   **优先使用**:
    *   始终遵循 **第3节** 定义的技术栈和实践。
    *   对于数据处理，优先使用不可变（immutable）的操作。
    *   对于异步操作，始终使用 `async/await`。
*   **避免使用**:
    *   **避免使用 `any` 类型。**
    *   避免在组件内部直接执行副作用（如API请求），应使用 `useEffect` 或 `TanStack Query`。
    *   避免使用全局变量进行状态管理，应使用 `Zustand`。
    *   避免在生产代码中使用 `console.log` 进行调试。

### 4.2 代码审查

在进行代码审查时，除常规检查外，请重点关注以下几点：

*   **UI/UX 符合性**: 是否遵循了 **第2节** 的设计准则？（例如，留白是否充足，动画是否有意义）。
*   **性能隐患**: 是否存在不必要的重复渲染？长列表是否实现了虚拟化？
*   **类型安全**: 是否存在 `any` 类型的滥用或类型定义不准确的情况？
*   **架构一致性**: 新增代码是否遵循了既定的模块化架构？
*   **可访问性 (a11y)**: 是否为交互元素提供了适当的 ARIA 属性？

### 4.3 调试与问题解决

*   **根源分析**: 协助调试时，不仅仅是修复表面问题，更要帮助分析问题的根本原因。
*   **提供多种方案**: 在可能的情况下，提供多种修复方案，并分析各自的优缺点。

```python
# 示例：一个常用的数据处理函数
def clean_and_normalize_text(text: str) -> str:
    """
    清洗并规范化文本数据，移除特殊字符并转换为小写。
    Args:
        text: 待处理的原始文本。
    Returns:
        清洗后的规范化文本。
    """
    import re
    text = text.lower()
    text = re.sub(r'[^a-z0-9\s]', '', text) # 移除特殊字符
    text = re.sub(r'\s+', ' ', text).strip() # 规范化空格
    return text

# 示例：API 请求模式
async def fetch_user_profile(user_id: str) -> dict:
    """
    从用户服务获取用户资料。
    Args:
        user_id: 用户的唯一ID。
    Returns:
        包含用户资料的字典。
    """
    import httpx
    try:
        response = await httpx.get(f"[https://api.example.com/users/](mdc:https:/api.example.com/users){user_id}")
        response.raise_for_status() # 检查HTTP错误
        return response.json()
    except httpx.HTTPStatusError as e:
        print(f"HTTP error occurred: {e.response.status_code} - {e.response.text}")
        raise
    except httpx.RequestError as e:
        print(f"An error occurred while requesting {e.request.url!r}: {e}")







        raise